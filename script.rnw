\documentclass{article}
\usepackage[utf8]{inputenc}

\begin{document}

\section{Introduction}
\label{sec:title}
Test

\subsection{Subtitle}
\label{ssec:subtitle}

Plain text.
<<List of packages that will be utilised in my application, eval=TRUE, echo=TRUE>>=
library(tidyverse)
library(knitr)
library(ggplot2)
library(ggmap)
library(maps)
library(mapdata)
library(maptools)
library(wordcloud)
library(tm)
library(RColorBrewer)
library(SnowballC)
library(wordcloud2)
library(Matrix)
library(tidytext)
library(magrittr)
library(webshot)

library(randomForest)
library(caret)
library(forcats)
library(plyr)


library(shiny)
library(trelliscope)
library(trelliscopejs)


options(stringsAsFactors = FALSE)
set.seed(4205426)
@

<<Import dataset from csv file, eval=TRUE, echo=TRUE>>=
# Import csv file from the Assets folder
orig_df = read.csv("Assets/globalterrorismdb.csv", na.strings=c("", "NA", "NULL"))  # read csv file
# Once dataset has been imported and asigned, create a working copy that we can use in our application
my_df <- orig_df
# # we will now use tha attach command to allow us to refrence features without having to state what table they are from in our script
# attach(my_df)
@

<<Data Exploration, eval=TRUE,echo=FALSE>>=
# Start by seeinghow many rows and feature our dataset has by using dim
dim(my_df)
names(my_df)
@

<<>>=
qplot(my_df$iyear, geom="histogram", binwidth=0.5, main="Histogram of Recorded Terrorist Incidents", xlab="Year", ylab="Quantity")
@



<<Map of all known Terrorist attacks, eval=TRUE, echo=TRUE>>=
worldmapcords <- map_data("world")
worldmap<- ggplot() + geom_polygon(data = worldmapcords, aes(x=long, y = lat, group = group)) + 
  coord_fixed(1.3)
worldmap + 
  geom_point(data = my_df, aes(x = longitude, y = latitude), color = "red", size = 0.1)
points(longitude, latitude, col = "red", cex = .6)
@


<<>>=
buildCorpus <- function(someText){
  # build a corpus, and specify the source to be character vectors
  myCorpus <- Corpus(VectorSource(someText))
  # I had to add this line to make the code work
  # For windows, it may not be an issue
  myCorpus <- tm_map(myCorpus,
                              content_transformer(function(x) iconv(x, to='UTF-8',
                                    sub='byte')))
  myCorpus <- tm_map(myCorpus, content_transformer(tolower))
  # remove punctuation
  myCorpus <- tm_map(myCorpus, removePunctuation)
  # remove numbers
  myCorpus <- tm_map(myCorpus, removeNumbers)
  # remove URLs
  removeURL <- function(x){
    sub("http[[:alnum:]]*", "", x)
  }
  ### myCorpus <- tm_map(myCorpus, removeURL, lazy=TRUE)
  myCorpus <- tm_map(myCorpus, content_transformer(removeURL)) #??
  # add two extra stop words: 'available' and 'via'
  # myStopwords <- c(stopwords("english"), "RT","rt")
  # remove "RT from stopwords
  # myStopwords <- setdiff(myStopwords, c("RT","rt"))
  # remove stopwords from corpus
  myCorpus <- tm_map(myCorpus, function(x) removeWords(x, stopwords("english")))
  myCorpus <- tm_map(myCorpus, stripWhitespace)
  # Return the text corpus
  return(myCorpus)
}

widgetThumbnail <- function(p, thumbName, width = 1024, height = 768) {
  phantom <- findPhantom()

  success <- FALSE
  if(phantom == "") {
    message("** phantomjs dependency could not be found - thumbnail cannot be generated (run phantomInstall() for details)")
  } else {
    res <- try({
      ff <- paste0(thumbName, ".html")
      ffjs <- paste0(thumbName, ".js")

      # don't want any padding
      p$sizingPolicy$padding <- 0
      suppressMessages(saveWidget(p, ff, selfcontained = FALSE))

      js <- paste0("var page = require('webpage').create();
                    page.viewportSize = { width: ", width,", height: ", height," };
                    page.clipRect = { top: 0, left: 0, width: ", width,", height: ", height," };
                    page.open('", ff, "', function(status) {
                    console.log(\"Status: \" + status);
                    if(status === \"success\") {
                    page.render('", thumbName, ".png');
                    }
                    phantom.exit();
                    });")
      cat(js, file = ffjs)
      system2(phantom, ffjs)
    })
    if(!inherits(res, "try-error")) {
      success <- TRUE
    }
    if(!file.exists(paste0(thumbName, ".png"))) {
      success <- FALSE
    }
  }
}

@




<<>>=
my_df.full_summary <- my_df[!(is.na(my_df$summary) | my_df$summary==""), ]
@


<<Summary splitting>>=
spec = c(set.1 = .1, set.2 = .1, set.3 = .1, set.4 = .1, set.5 = .1, set.6 = .1, set.7 = .1, set.8 = .1, set.9 = .1, set.10 = .1)

g = sample(cut(
  seq(nrow(my_df.full_summary)), 
  nrow(my_df.full_summary)*cumsum(c(0,spec)),
  labels = names(spec)
))

summarySplits = split(my_df.full_summary, g)

@

<<Construct DocumentTermMatrix from set1 then create dataframe with word frequency, eval=FALSE>>=
# test<-as.data.frame(summarySplits$set.1$summary)
my_df.AllSummary<-as.data.frame(my_df.full_summary$summary)
my_df.AllSummary.corpus <- buildCorpus(my_df.AllSummary)
AllSummary.dtm <- TermDocumentMatrix(my_df.AllSummary.corpus)
AllSummary.m <- as.matrix(AllSummary.dtm)
AllSummary.v <- sort(rowSums(AllSummary.m),decreasing=TRUE)
AllSummary.d <- data.frame(word = names(AllSummary.v),freq=AllSummary.v)
@



<<wordcloudplot, fig.show='hold', echo=TRUE, eval=FALSE>>=
# figPath = system.file("Assets/bomb.png",package = "wordcloud2")
wordcloud2(d, figPath = "Assets/world.png", size = 1.5,color = "random-light")
widgetThumbnail(p = liam, thumbName = "plot", height = 862, width = 1509)
@


<<AllGroup Known and Unknown Dataset creation>>=

my_df.AllGroups <- subset(my_df, select=c("gname", "region", "nkill", "attacktype1", "success", "weaptype1"))

my_df.AllGroups$gname <- factor(my_df.AllGroups$gname)


my_df.AllGroups$gname <- fct_lump(my_df.AllGroups$gname, n = 30)
# my_df.AllGroups$weaptype1 <- str_replace_all(my_df.AllGroups$weaptype1, "[^[:alnum:]]", " ")
# 
# my_df.AllGroups$attacktype1_txt <- str_replace_all(my_df.AllGroups$attacktype1_txt, "[^[:alnum:]]", " ")

my_df.AllGroups$gname <- str_replace_all(my_df.AllGroups$gname, "[^[:alnum:]]", " ")

my_df.AllGroups=na.omit(my_df.AllGroups)

my_df.AllGroups.Known <- my_df.AllGroups[!(my_df.AllGroups$gname =="Unknown"), ]

my_df.AllGroups.Unknown <- my_df.AllGroups[(my_df.AllGroups$gname =="Unknown"), ]

my_df.AllGroups.Known$gname <- factor(my_df.AllGroups.Known$gname)
my_df.AllGroups.Known$nkill <- as.numeric(my_df.AllGroups.Known$nkill)
my_df.AllGroups.Known$region <- factor(my_df.AllGroups.Known$region)
my_df.AllGroups.Known$success <- factor(my_df.AllGroups.Known$success)
my_df.AllGroups.Known$attacktype1 <- factor(my_df.AllGroups.Known$attacktype1)
my_df.AllGroups.Known$weaptype1 <- factor(my_df.AllGroups.Known$weaptype1)

@

<<Count group attack occurences and plot, eval=TRUE, echo=TRUE>>=
my_df.AllGroups.freq <- count(my_df$gname)
my_df.AllGroups.freq <- my_df.AllGroups.freq[!(my_df.AllGroups.freq$x =="Unknown"), ]
my_df.number.of.groups <- my_df.AllGroups.freq[order(my_df.AllGroups.freq$freq, decreasing = T),]
my_df.group.barplot<-ggplot(data=my_df.number.of.groups[1:10,], aes(x=x, y=freq)) + geom_bar(stat="identity")+
  coord_flip()
my_df.group.barplot
@


<<Count UK group attack occurences and plot, eval=TRUE, echo=TRUE>>=
my_df.UK.AllGroups <- my_df[my_df$country==603,]
my_df.UK.AllGroups.freq <- count(my_df.UK.AllGroups$gname)
my_df.UK.AllGroups.freq <- my_df.UK.AllGroups.freq[!(my_df.UK.AllGroups.freq$x =="Unknown"), ]
my_df.uk.number.of.groups <- my_df.UK.AllGroups.freq[order(my_df.UK.AllGroups.freq$freq, decreasing = T),]
my_df.uk.group.barplot<-ggplot(data=my_df.uk.number.of.groups[1:10,], aes(x=x, y=freq)) + geom_bar(stat="identity") +
  coord_flip()
my_df.uk.group.barplot
@


<<>>=
my_df.UK.AllGroups.SummaryAT <- subset(my_df.UK.AllGroups, select=c("summary", "attacktype1"))
my_df.UK.AllGroups.SummaryAT = na.omit(my_df.UK.AllGroups.SummaryAT)
@

<<>>=
uk.corpus <- buildCorpus(my_df.UK.AllGroups.SummaryAT$summary)
uk.dtm <- TermDocumentMatrix(uk.corpus)
uk.m <- as.matrix(uk.dtm)
uk.v <- sort(rowSums(uk.m),decreasing=TRUE)
uk.d <- data.frame(word = names(uk.v),freq=uk.v)
@

<<>>=
wordcloud2(uk.d, figPath = "Assets/uk.png", size = 1.5,color = "random-light")
@




<<Creates group ids from gname refrenced from frequency matrix, eval=TRUE>>=
for (i in 1:which.max(my_df.AllGroups.freq$x)){
  my_df.AllGroups.Known$groupid[my_df.AllGroups.Known$gname == my_df.AllGroups.freq$x[i]] <- i
}
my_df.AllGroups.Known$gname <- NULL
my_df.AllGroups.Known$groupid <- as.numeric(my_df.AllGroups.Known$groupid)
my_df.AllGroups.Known$groupid <- factor(my_df.AllGroups.Known$groupid)
my_df.AllGroups.Known <- my_df.AllGroups.Known %>%
  select(groupid, everything())
@


<<eval=FALSE>>=
inTrain <- createDataPartition(y=my_df.AllGroups.Known$groupid,
p=.5,list=FALSE)
group.data.training <- my_df.AllGroups.Known[inTrain,]
# group.data.training.test <- group.data.training[1:100,]
group.data.testing <- my_df.AllGroups.Known[-inTrain,]
@



<<>>=
set.seed(4205426)
ntrees <- 100
# create dataframe to store accuracies and corresponding number of trees
df_guff <- data.frame(NTrees=as.numeric(),
Accuracy=as.numeric())
# fit randomForest 10 times, and store the results
# vary number of trees in every iteration


for (i in 1:10){
  RFModel <- randomForest(group.data.training[1:100,-1], group.data.training[1:100,1], xtest=group.data.testing[,-1], ytest=group.data.testing[,1], ntree=ntrees, proximity=TRUE, importance=TRUE)
  # Test the RF model for this run
  preds <- levels(group.data.training[,1])[RFModel$test$predicted]
  # compute accuracy
  auc <- (sum(preds ==group.data.testing[,1])/nrow(group.data.testing))*100
  df_guff <- rbind(df_guff, data.frame(NTrees=ntrees,Accuracy=auc))
  ntrees <- ntrees + 100
  # Test the RF model for this run
  preds <- levels(group.data.training[,1])[RFModel$test$predicted]
  # compute accuracy
  auc <- (sum(preds ==group.data.testing[,1])/nrow(group.data.testing))*100
  df_guff <- rbind(df_guff, data.frame(NTrees=ntrees,Accuracy=auc))
  ntrees <- ntrees + 100
}# end for loop
@

<<>>=
train=sample(1:nrow(my_df.AllGroups.Known),300)
rf.Groupid=randomForest(groupid~.,data=my_df.AllGroups.Known,subset=train)
@



<<>>=
detach(my_df)
attach(group.data.training)
mymodel <- glm(groupid ~.,family=binomial,data=group.data.training[,-1])
@



<<>>=
propos <- predict(mymodel,newdata=group.data.testing[,-1],type='response')
# assing predictions to 0 or 1 based on the propbability
predictions <- ifelse(propos > 0.5,1,0)
# compute test error
test_err <- mean(predictions != group.data.testing$groupid)
# accuracy is 1-test_err
print(paste('Accuracy',1-test_err))
@




\subsection{Another subtitle}
\label{ssec:another_subtitle}

More plain text.

\end{document}